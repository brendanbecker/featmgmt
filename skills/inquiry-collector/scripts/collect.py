#!/usr/bin/env python3
"""Main orchestrator for inquiry output collection.

This script coordinates the collection of research outputs from
inquiry agents and generates the summary for the synthesis phase.

Usage:
    python collect.py INQ-001 --mode ccmux
    python collect.py INQ-001 --mode file
    python collect.py INQ-001 --mode file --timeout 600
"""

import argparse
import json
import sys
from pathlib import Path

try:
    from .ccmux_monitor import CcmuxMonitor, create_monitor_instructions
    from .extract import extract_agent_research
    from .file_monitor import FileMonitor, check_files, wait_for_files
    from .summarize import Summarizer, generate_summary_markdown
    from .utils import (
        ensure_research_dir,
        find_inquiry_path,
        get_date,
        get_timestamp,
        load_inquiry_report,
        print_error,
        print_progress,
        print_warning,
        save_inquiry_report,
        update_inquiry_phase,
    )
except ImportError:
    from ccmux_monitor import CcmuxMonitor, create_monitor_instructions
    from extract import extract_agent_research
    from file_monitor import FileMonitor, check_files, wait_for_files
    from summarize import Summarizer, generate_summary_markdown
    from utils import (
        ensure_research_dir,
        find_inquiry_path,
        get_date,
        get_timestamp,
        load_inquiry_report,
        print_error,
        print_progress,
        print_warning,
        save_inquiry_report,
        update_inquiry_phase,
    )


def generate_agent_report(
    research: "AgentResearch",
    inquiry_id: str,
    output_path: Path,
) -> None:
    """Generate a standardized agent research report file.

    Args:
        research: Extracted research data
        inquiry_id: The inquiry ID
        output_path: Path to write the report
    """
    timestamp = get_timestamp()

    lines = [
        f"# Agent {research.agent_id} Research Report",
        "",
        f"**Inquiry**: {inquiry_id}",
        f"**Agent**: {research.agent_id}",
    ]

    if research.metadata.get("agent_identifier"):
        lines.append(f"**Model**: {research.metadata['agent_identifier']}")

    lines.extend([
        f"**Completed**: {timestamp}",
        f"**Word Count**: {research.metadata.get('word_count', 'N/A')}",
        "",
    ])

    # Sections
    sections = [
        ("Problem Analysis", research.problem_analysis),
        ("Approaches Explored", research.approaches_explored),
        ("Evidence Gathered", research.evidence_gathered),
        ("Key Findings", research.key_findings),
        ("Recommendations", research.recommendations),
    ]

    for title, content in sections:
        lines.append(f"## {title}")
        lines.append("")
        if content:
            lines.append(content)
        else:
            lines.append("*No content extracted for this section.*")
        lines.append("")

    # If extraction was limited, include raw content
    if research.completeness_score() < 0.4 and research.raw_content:
        lines.extend([
            "## Raw Output",
            "",
            "The structured extraction was limited. Original output preserved below:",
            "",
            "```",
            research.raw_content[:5000],  # Limit size
            "```" if len(research.raw_content) <= 5000 else "```\n\n*(truncated)*",
            "",
        ])

    lines.extend([
        "---",
        f"*Generated by inquiry-collector at {timestamp}*",
    ])

    output_path.write_text("\n".join(lines))


def collect_from_files(
    inquiry_path: Path,
    expected_agents: int,
    timeout: int = 300,
    dry_run: bool = False,
    force: bool = False,
) -> tuple[list, bool]:
    """Collect research outputs from files.

    Args:
        inquiry_path: Path to inquiry directory
        expected_agents: Number of expected agents
        timeout: Timeout in seconds
        dry_run: If True, don't write files
        force: If True, overwrite existing files

    Returns:
        Tuple of (extracted_reports, all_complete)
    """
    print_progress(f"Scanning for research files in {inquiry_path}/research/...")

    files, summary = wait_for_files(
        inquiry_path,
        expected_agents,
        timeout=timeout,
    )

    print_progress(f"\nFound {summary['found']} files, {summary['complete']} complete")

    if summary["missing_agents"]:
        print_warning(f"Missing agents: {summary['missing_agents']}")

    # Extract content from each file
    research_dir = ensure_research_dir(inquiry_path)
    extracted = []

    for file_info in files:
        if not file_info.content:
            continue

        agent_id = str(file_info.agent_number)
        research = extract_agent_research(file_info.content, agent_id)
        extracted.append(research)

        print_progress(
            f"Agent {agent_id}: {research.completeness_score():.0%} complete "
            f"({len(file_info.content)} chars)"
        )

        # Generate standardized report (unless it's the source file)
        output_path = research_dir / f"agent-{agent_id}.md"
        if output_path != file_info.path:
            if not dry_run and (force or not output_path.exists()):
                generate_agent_report(research, inquiry_path.name, output_path)
                print_progress(f"  -> Generated {output_path.name}")

    all_complete = summary["complete"] >= expected_agents
    return extracted, all_complete


def collect_ccmux_instructions(
    inquiry_path: Path,
    expected_agents: int,
    timeout: int = 300,
) -> str:
    """Generate instructions for ccmux-based collection.

    Since ccmux tools are MCP tools that must be called by Claude,
    this function returns instructions for the collection workflow.
    """
    report = load_inquiry_report(inquiry_path)
    inquiry_id = report.get("inquiry_id", inquiry_path.name.split("-")[0] + "-" + inquiry_path.name.split("-")[1])

    instructions = create_monitor_instructions(
        inquiry_id,
        expected_agents,
        timeout,
    )

    instructions += f"""
### Files to Generate

For each completed agent session, create:
- `{inquiry_path}/research/agent-N.md`

Then generate:
- `{inquiry_path}/SUMMARY.md`

Finally, update:
- `{inquiry_path}/inquiry_report.json` (phase: research -> synthesis)
"""

    return instructions


def generate_summary(
    inquiry_path: Path,
    extracted_reports: list,
    dry_run: bool = False,
) -> Path:
    """Generate SUMMARY.md from extracted reports.

    Args:
        inquiry_path: Path to inquiry directory
        extracted_reports: List of AgentResearch objects
        dry_run: If True, don't write file

    Returns:
        Path to generated summary file
    """
    report = load_inquiry_report(inquiry_path)
    inquiry_id = report.get("inquiry_id", "INQ-???")
    inquiry_title = report.get("title", "")

    summarizer = Summarizer(inquiry_id, inquiry_title)

    for research in extracted_reports:
        summarizer.add_report(research)

    summary = summarizer.analyze()
    markdown = generate_summary_markdown(summary)

    summary_path = inquiry_path / "SUMMARY.md"

    if not dry_run:
        summary_path.write_text(markdown)
        print_progress(f"Generated {summary_path}")

    return summary_path


def update_status(
    inquiry_path: Path,
    all_complete: bool,
    completed_count: int,
    expected_count: int,
    dry_run: bool = False,
) -> None:
    """Update inquiry status after collection.

    Args:
        inquiry_path: Path to inquiry directory
        all_complete: Whether all agents completed
        completed_count: Number of completed agents
        expected_count: Number of expected agents
        dry_run: If True, don't write changes
    """
    if dry_run:
        if all_complete:
            print_progress("Would update phase: research -> synthesis")
        else:
            print_progress(f"Would not update phase (incomplete: {completed_count}/{expected_count})")
        return

    if all_complete:
        notes = f"Completed with {completed_count}/{expected_count} agents"
        update_inquiry_phase(inquiry_path, "synthesis", notes)
        print_progress("Updated inquiry phase: research -> synthesis")
    else:
        print_warning(
            f"Inquiry remains in 'research' phase "
            f"({completed_count}/{expected_count} complete)"
        )


def main():
    """Main entry point for the collect script."""
    parser = argparse.ArgumentParser(
        description="Collect research outputs from inquiry agents",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python -m inquiry_collector.scripts.collect INQ-001 --mode file
  python -m inquiry_collector.scripts.collect INQ-001 --mode ccmux --timeout 600
  python -m inquiry_collector.scripts.collect INQ-001 --dry-run
        """,
    )

    parser.add_argument(
        "inquiry_id",
        help="The inquiry ID (e.g., INQ-001)",
    )
    parser.add_argument(
        "--mode",
        choices=["ccmux", "file"],
        default="file",
        help="Collection mode (default: file)",
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=300,
        help="Timeout in seconds (default: 300)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without writing files",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing research files",
    )
    parser.add_argument(
        "--base-path",
        type=Path,
        help="Base path for finding inquiry (default: current directory)",
    )

    args = parser.parse_args()

    # Find inquiry
    inquiry_path = find_inquiry_path(args.inquiry_id, args.base_path)
    if not inquiry_path:
        print_error(f"Inquiry not found: {args.inquiry_id}")
        print_error("Searched in: ./inquiries/, ./feature-management/inquiries/")
        sys.exit(1)

    print_progress(f"Found inquiry at: {inquiry_path}")

    # Load inquiry report
    try:
        report = load_inquiry_report(inquiry_path)
    except FileNotFoundError as e:
        print_error(str(e))
        sys.exit(1)

    expected_agents = report.get("research_agents", 2)
    current_phase = report.get("phase", "new")

    print_progress(f"Inquiry phase: {current_phase}")
    print_progress(f"Expected agents: {expected_agents}")

    # Check phase
    if current_phase not in ("new", "research"):
        print_warning(f"Inquiry is in '{current_phase}' phase, not 'research'")
        if not args.force:
            print_error("Use --force to proceed anyway")
            sys.exit(1)

    # Collect based on mode
    if args.mode == "ccmux":
        # For ccmux mode, print instructions since MCP tools need Claude
        instructions = collect_ccmux_instructions(
            inquiry_path,
            expected_agents,
            args.timeout,
        )
        print(instructions)
        print_progress("\nFollow the instructions above to complete collection via ccmux.")
        sys.exit(0)

    elif args.mode == "file":
        extracted, all_complete = collect_from_files(
            inquiry_path,
            expected_agents,
            timeout=args.timeout,
            dry_run=args.dry_run,
            force=args.force,
        )

        if not extracted:
            print_error("No research outputs found")
            sys.exit(1)

        # Generate summary
        generate_summary(inquiry_path, extracted, dry_run=args.dry_run)

        # Update status
        update_status(
            inquiry_path,
            all_complete,
            len(extracted),
            expected_agents,
            dry_run=args.dry_run,
        )

        print_progress(f"\nCollection complete. {len(extracted)} reports processed.")

        if all_complete:
            print_progress(f"\n{args.inquiry_id} is ready for Phase 2: Synthesis")
        else:
            print_progress(f"\n{args.inquiry_id} has incomplete agents. Re-run later or use --force.")


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
Consensus Builder for Inquiry Orchestration

Generates consensus documents and prepares FEAT work items for Phase 4.
"""

import json
import re
import sys
from datetime import date
from pathlib import Path
from typing import Optional

from .phase_manager import load_inquiry, save_inquiry, find_inquiry


CONSENSUS_TEMPLATE = """# Consensus: {title}

**Inquiry**: {inquiry_id}
**Date**: {date}
**Phase**: 4 - Consensus Reached

## Executive Summary

[2-3 paragraphs summarizing the final decision and key rationale]

## Decision Record

{decision_sections}

## Implementation Approach

### Recommended Solution

[Detailed description of the chosen approach]

### Technical Specifications

| Aspect | Decision | Rationale |
|--------|----------|-----------|
{specs_table}

### Success Criteria

- [ ] [Criterion 1]
- [ ] [Criterion 2]
- [ ] [Criterion 3]

### Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| [Risk 1] | High/Medium/Low | High/Medium/Low | [Mitigation strategy] |

## Alternatives Considered

{alternatives_section}

## Work Items to Spawn

{work_items_section}

## Constraints Verification

| Constraint | Satisfied | How |
|------------|-----------|-----|
{constraints_table}

## Approval

**Consensus Reached**: {date}
**Source Inquiry**: {inquiry_id}
**Deliberation Duration**: [X days]
**Research Agents**: {agent_count}

### Participants

- Research Agents: {agent_count}
- Synthesis Agent: 1
- Debate Advocates: 2 per decision point

### Confidence Level

**Overall Confidence**: [High/Medium/Low]

**Rationale**: [Why this confidence level]

---
*Generated by inquiry orchestration on {date}*
"""


DECISION_SECTION_TEMPLATE = """
### Decision {num}: {topic}

**Resolution**: {resolution}

**Rationale**:
{rationale}

**Key Factors**:
{factors}

**Trade-offs Accepted**:
{tradeoffs}
"""


ALTERNATIVE_TEMPLATE = """
### Alternative {num}: {name}

**Description**: {description}

**Reason Rejected**: {reason}

**Valid Points**: {valid_points}
"""


WORK_ITEM_TEMPLATE = """
### FEAT-XXX: {title}

**Type**: {type}
**Priority**: {priority}
**Estimated Effort**: {effort}

**Description**:
{description}

**Acceptance Criteria**:
- [ ] [Criterion 1]
- [ ] [Criterion 2]

**Source**: {inquiry_id} - {decision_ref}
"""


def parse_debate_resolutions(debate_path: Path) -> list[dict]:
    """
    Parse DEBATE.md to extract resolutions.

    Returns list of decisions with resolutions.
    """
    if not debate_path.exists():
        return []

    content = debate_path.read_text()
    decisions = []

    # Find all decision point sections
    decision_sections = re.findall(
        r'### Decision Point (\d+):\s*([^\n]+)(.*?)(?=### Decision Point|\Z)',
        content,
        re.DOTALL
    )

    for num, topic, section in decision_sections:
        resolution_match = re.search(
            r'\*\*Prevailing Position\*\*:\s*([^\n]+)',
            section
        )
        rationale_match = re.search(
            r'\*\*Rationale\*\*:\s*\n(.*?)(?=\*\*|\n---|\Z)',
            section,
            re.DOTALL
        )
        confidence_match = re.search(
            r'\*\*Confidence\*\*:\s*([^\n]+)',
            section
        )

        decisions.append({
            "num": int(num),
            "topic": topic.strip(),
            "resolution": resolution_match.group(1).strip() if resolution_match else "[Not specified]",
            "rationale": rationale_match.group(1).strip() if rationale_match else "[See debate document]",
            "confidence": confidence_match.group(1).strip() if confidence_match else "Medium"
        })

    return decisions


def generate_decision_sections(decisions: list[dict]) -> str:
    """Generate decision sections for consensus document."""
    if not decisions:
        return DECISION_SECTION_TEMPLATE.format(
            num=1,
            topic="[Topic from debate]",
            resolution="[Resolution]",
            rationale="[Rationale for decision]",
            factors="- [Factor 1]\n- [Factor 2]",
            tradeoffs="- [Trade-off 1]\n- [Trade-off 2]"
        )

    sections = []
    for d in decisions:
        sections.append(DECISION_SECTION_TEMPLATE.format(
            num=d["num"],
            topic=d["topic"],
            resolution=d["resolution"],
            rationale=d["rationale"],
            factors="- [Factor 1]\n- [Factor 2]",
            tradeoffs="- [Trade-off 1]\n- [Trade-off 2]"
        ))

    return "\n".join(sections)


def generate_constraints_table(constraints: list[str]) -> str:
    """Generate constraints verification table."""
    if not constraints:
        return "| [Constraint] | Yes/No | [How satisfied] |"

    rows = []
    for c in constraints:
        rows.append(f"| {c} | | |")
    return "\n".join(rows)


def create_consensus_template(inquiry_path: Path) -> str:
    """Create a consensus document template from debate results."""
    report = load_inquiry(inquiry_path)
    debate_path = inquiry_path / "DEBATE.md"
    decisions = parse_debate_resolutions(debate_path)

    research_dir = inquiry_path / "research"
    agent_count = len(list(research_dir.glob("agent-*.md"))) if research_dir.exists() else 0

    return CONSENSUS_TEMPLATE.format(
        title=report.get("title", "Untitled"),
        inquiry_id=report.get("inquiry_id", "Unknown"),
        date=date.today().isoformat(),
        decision_sections=generate_decision_sections(decisions),
        specs_table="| [Aspect] | [Decision] | [Rationale] |",
        alternatives_section=ALTERNATIVE_TEMPLATE.format(
            num=1,
            name="[Alternative Name]",
            description="[What this alternative proposed]",
            reason="[Why it was rejected]",
            valid_points="[What was valuable about this approach]"
        ),
        work_items_section=WORK_ITEM_TEMPLATE.format(
            title="[Feature Title]",
            type="new_feature",
            priority="P1",
            effort="medium",
            description="Implementation based on consensus decision",
            inquiry_id=report.get("inquiry_id", "Unknown"),
            decision_ref="Decision 1"
        ),
        constraints_table=generate_constraints_table(report.get("constraints", [])),
        agent_count=agent_count
    )


def extract_feat_requirements(inquiry_path: Path) -> list[dict]:
    """
    Extract FEAT requirements from consensus or generate suggestions.

    Returns list of suggested FEAT work items.
    """
    report = load_inquiry(inquiry_path)
    consensus_path = inquiry_path / "CONSENSUS.md"
    debate_path = inquiry_path / "DEBATE.md"

    feats = []

    # Try to extract from consensus
    if consensus_path.exists():
        content = consensus_path.read_text()
        work_items_match = re.search(
            r'## Work Items to Spawn\s*\n(.*?)(?=\n## |\Z)',
            content,
            re.DOTALL
        )

        if work_items_match:
            section = work_items_match.group(1)
            # Parse FEAT sections
            feat_matches = re.findall(
                r'### FEAT-\w+:\s*([^\n]+)\s*\n'
                r'.*?\*\*Type\*\*:\s*([^\n]+)\s*\n'
                r'.*?\*\*Priority\*\*:\s*([^\n]+)\s*\n'
                r'.*?\*\*Estimated Effort\*\*:\s*([^\n]+)',
                section,
                re.DOTALL
            )
            for title, feat_type, priority, effort in feat_matches:
                feats.append({
                    "title": title.strip(),
                    "type": feat_type.strip(),
                    "priority": priority.strip(),
                    "effort": effort.strip(),
                    "component": report.get("component", "unknown"),
                    "source_inquiry": report.get("inquiry_id")
                })

    # If no feats found, generate suggestion from decisions
    if not feats:
        decisions = parse_debate_resolutions(debate_path) if debate_path.exists() else []
        for d in decisions:
            feats.append({
                "title": f"Implement {d['topic']} based on {d['resolution']}",
                "type": "new_feature",
                "priority": "P1",
                "effort": "medium",
                "component": report.get("component", "unknown"),
                "source_inquiry": report.get("inquiry_id"),
                "auto_generated": True
            })

    return feats


def update_inquiry_with_feats(inquiry_path: Path, feat_ids: list[str]) -> dict:
    """Update inquiry_report.json with spawned FEAT IDs."""
    report = load_inquiry(inquiry_path)

    if "spawned_features" not in report:
        report["spawned_features"] = []

    for feat_id in feat_ids:
        if feat_id not in report["spawned_features"]:
            report["spawned_features"].append(feat_id)

    save_inquiry(inquiry_path, report)
    return report


def generate_feat_creation_commands(inquiry_path: Path) -> str:
    """Generate CLI commands to create FEAT work items."""
    feats = extract_feat_requirements(inquiry_path)

    if not feats:
        return "# No FEAT requirements found in consensus document"

    commands = ["# Commands to create FEAT work items from consensus:\n"]
    for i, feat in enumerate(feats, 1):
        cmd = f"""
# FEAT {i}: {feat['title']}
/work-item-creation FEAT \\
  --title "{feat['title']}" \\
  --component "{feat['component']}" \\
  --type "{feat['type']}" \\
  --priority "{feat['priority']}" \\
  --effort "{feat['effort']}" \\
  --source-inquiry "{feat['source_inquiry']}"
"""
        commands.append(cmd)

    return "\n".join(commands)


def main():
    """CLI interface for consensus building."""
    import argparse

    parser = argparse.ArgumentParser(description="Generate consensus documents and FEAT requirements")
    parser.add_argument("inquiry", help="Inquiry ID or path")
    parser.add_argument("--output", choices=["template", "feats", "commands"],
                        default="template", help="What to generate")
    parser.add_argument("--write", action="store_true",
                        help="Write template to CONSENSUS.md")
    parser.add_argument("--add-feat", action="append", dest="feat_ids",
                        help="Add FEAT ID to spawned_features")
    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()

    inquiry_path = find_inquiry(args.inquiry)
    if not inquiry_path:
        print(f"Error: Could not find inquiry '{args.inquiry}'", file=sys.stderr)
        sys.exit(1)

    try:
        if args.feat_ids:
            report = update_inquiry_with_feats(inquiry_path, args.feat_ids)
            if args.json:
                print(json.dumps({"spawned_features": report.get("spawned_features", [])}))
            else:
                print(f"Updated spawned_features: {report.get('spawned_features', [])}")
            return

        if args.output == "template":
            template = create_consensus_template(inquiry_path)
            if args.write:
                consensus_file = inquiry_path / "CONSENSUS.md"
                consensus_file.write_text(template)
                if args.json:
                    print(json.dumps({"success": True, "file": str(consensus_file)}))
                else:
                    print(f"Template written to {consensus_file}")
            else:
                if args.json:
                    print(json.dumps({"template": template}))
                else:
                    print(template)

        elif args.output == "feats":
            feats = extract_feat_requirements(inquiry_path)
            if args.json:
                print(json.dumps({"feats": feats, "count": len(feats)}, indent=2))
            else:
                print(f"Found {len(feats)} FEAT requirements:\n")
                for feat in feats:
                    print(f"  - {feat['title']}")
                    print(f"    Type: {feat['type']}, Priority: {feat['priority']}")
                    print(f"    Effort: {feat['effort']}, Component: {feat['component']}")
                    if feat.get("auto_generated"):
                        print("    (Auto-generated suggestion)")
                    print()

        elif args.output == "commands":
            commands = generate_feat_creation_commands(inquiry_path)
            if args.json:
                print(json.dumps({"commands": commands}))
            else:
                print(commands)

    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
